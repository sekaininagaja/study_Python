Chapter 7 – Pattern Matching with Regular Expressions  
https://automatetheboringstuff.com/chapter7/

# 正規表現とパターンマッチング 概要

この章では、正規表現を使用せずにテキストパターンを検索するプログラムを作成し、正規表現を使用してコードの膨大化を防ぐ方法を見ていきます。  
基本的な正規表現のマッチングを行い、文字列の置換や独自の文字クラスの作成など、より強力な機能に移行します。  
この章の最後に、テキストブロックから電話番号と電子メールアドレスを自動的に抽出するプログラムを作成します。  

# 正規表現を使用しないテキストのパターンの検索

文字列で電話番号を探したいとします。  
電話番号のパターンは下記のとおりです。  

```
3つの数字、ハイフン、3つの数字、ハイフン、および4つの数字
例：415-555-4242
```

文字列がこのパターンと一致するかどうかをチェックして`True`または`False`を返す`is_phone_number()`という名前の関数を作成します。

- is_phone_number()関数がチェックすること
1. 文字列が12文字であること
1. テキスト最初の3文字(市外局番)が数字だけで構成されていること
1. テキスト最初の3文字のあとにハイフンが1つ、数字が3つ、ハイフンが1つ、数字が4つ…のパターンを満たすこと
1. 以上を満たす場合は`True`

```python
# isPhoneNumber.py 結果
415-555-4242 is a phone numver:
True
Moshi moshi is a phone number:
False
```

forループの各反復で、メッセージからの12文字の新しいチャンクが変数チャンクに割り当てられます。  
たとえば、最初の反復では、iは0、チャンクにはメッセージ[0:12]（つまり、 'Call me at 4'）が割り当てられます。  
次の反復では、iは1で、チャンクにはメッセージ[1:13]（文字列 'all at at 41'）が割り当てられます。  
チャンクを`is_phone_number()`に渡して、電話番号パターンと一致するかどうかを確認します。  
一致する場合は、チャンクをprintします。

メッセージをループし続けると、最終的にチャンク内の12文字が電話番号になります。  
ループは文字列全体を調べ、各12文字のピースをテストし、`is_phone_number()` を満たすチャンクをprintします。  
すべてのメッセージを精査したら、Doneをprintします。  

```python
message = 'Call me at 415-555-1011 tomorrow. 415-555-9999 is my office.'
for i in range(len(message)):
      chunk = message[i:i+12]
      if isPhoneNumber(chunk):
      print('Phone number found: ' + chunk)
print('Done')
```

``` python
# メッセージ内から電話番号だけ抜き出す
Phone number found: 415-555-1011
Phone number found: 415-555-9999
Done
```

この例でのメッセージ文字列は短いものの、数百万文字でもプログラムは1秒未満で実行されます。  
正規表現を使って電話番号を見つける同様のプログラムも1秒未満で実行されますが、正規表現ではこれらのプログラムをより早く書けます。  


# 正規表現でのテキストのパターンの検索

先ほどの電話番号検索プログラムも機能しますが、たくさんのコードを書くわりには下記のような制限があります。  
- 17行のis_phone_number()関数で、電話番号のパターンは1つしか対応できない  
  - `415.555.4242` や `(415)555-4242` のような形式に対応できない
  - 電話番号に `415-555-4242 x99` のような内線番号に対応できない
- これらに対応するためには、追加パターンのコードを書かないといけない

上記の制限は、正規表現を使って表すことができます。
たとえば、正規表現の`\d`は、数字(つまり0～9のいずれか)を表します。  
正規表現 `\d\d\d-\d\d\d-\d\d\d\d` は、`3つの数字、ハイフン、3つの数字、ハイフン、4つの数字` にマッチします。

上記の正規表現はもっと洗練できます。  
パターンの後に中括弧（{3}）を3つ追加することで、「このパターンを3回一致させる」という意味になります。  
`\d{3}-\d{3}-\d{4}`


## 正規表現オブジェクトの作成

Pythonのすべての正規表現関数はreモジュールにあります。  
このモジュールをインポートするには、対話型シェルに次のように入力します。  

```python
>>> import re
```

この章で続く例のほとんどはreモジュールを必要とするので、あなたが書いたスクリプトの始めやIDLEを再起動するときには必ず忘れずにインポートしてください。  
それ以外の場合は、`NameError: name 're' is not defined` というエラーメッセージが表示されます。   
正規表現を表す文字列値を`re.compile()`に渡すと、正規表現パターンオブジェクト(または単純に正規表現オブジェクト)が返されます。

電話番号パターンと一致するRegexオブジェクトを作成するには、対話型シェルに次のように入力します。  
これで、phone_number_regex変数に正規表現オブジェクトが格納されます。  

```python
>>> phone_number_regex = re.compile(r'\d\d\d-\d\d\d-\d\d\d\d')
```

生の文字列`(r'\d\d\d-\d\d\d-\d\d\d\d')`を `re.compile()` に渡しているのはなぜか。  

Pythonでも字をエスケープするにはバックスラッシュ`\` を使用します。
文字列値 `\n` は改行文字を表します。  
単一のバックスラッシュは `\\` と表します。  
だから `\\n` は 「バックスラッシュ + 小文字のn」を表しています。  

しかし、上記の例のように文字列値の最初の引用符の前に`r`を置くと、文字列を生の文字列としてマークすることができます。  
生の文字列はバックスラッシュをエスケープ文字として解釈しません。  
正規表現ではバックスラッシュが頻繁に使用されるので、余分なバックスラッシュを入力するのではなく、生の文字列を`re.compile()` 関数に渡すほうが便利です。  

```python
# 余計なバックスラッシュがはいるとわかりにくい
\\d\\d\\d-\\d\\d\\d-\\d\\d\\d\\d

# 生の文字列を使ったほうがわかりやすい
r'\d\d\d-\d\d\d-\d\d\d\d'
```
